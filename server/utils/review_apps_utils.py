"""Review Apps utility functions for direct use as tools by Claude."""

from typing import Any, Dict, Optional

import mlflow
import mlflow.genai.labeling as labeling

from server.utils.databricks_auth import get_managed_evals_api_url
from server.utils.proxy import fetch_databricks


class ReviewAppsUtils:
  """Utility class for Review Apps operations that can be used directly by Claude."""

  def __init__(self):
    """Initialize with cache."""
    # Cache for experiment_id -> review_app_id mapping (1:1 relationship)
    self._experiment_to_review_app_id_cache = {}

  async def list_review_apps(
    self,
    filter_string: Optional[str] = None,
    page_size: int = 500,
    page_token: Optional[str] = None,
  ) -> Dict[str, Any]:
    """List review apps with optional filtering.

    Args:
        filter_string: Filter string (e.g., experiment_id=123)
        page_size: Number of items per page (1-1000)
        page_token: Pagination token for next page

    Returns:
        Dictionary containing list of review apps and pagination info
    """
    params = {'page_size': page_size}
    if filter_string:
      params['filter'] = filter_string
    if page_token:
      params['page_token'] = page_token

    url = get_managed_evals_api_url('/review-apps')
    response = await fetch_databricks(
      method='GET',
      url=url,
      params=params,
    )

    return response

  async def create_review_app(self, review_app_data: Dict[str, Any]) -> Dict[str, Any]:
    """Create a new review app for an experiment.

    Args:
        review_app_data: Review app data (without review_app_id)

    Returns:
        Dictionary containing created review app
    """
    # Remove review_app_id if present (it's generated by the server)
    data = review_app_data.copy()
    data.pop('review_app_id', None)

    url = get_managed_evals_api_url('/review-apps')
    response = await fetch_databricks(
      method='POST',
      url=url,
      data=data,
    )

    return response

  async def get_review_app(self, review_app_id: str) -> Dict[str, Any]:
    """Get a specific review app by ID.

    Args:
        review_app_id: The review app ID

    Returns:
        Dictionary containing review app details
    """
    url = get_managed_evals_api_url(f'/review-apps/{review_app_id}')
    response = await fetch_databricks(
      method='GET',
      url=url,
    )

    return response

  async def update_review_app(
    self,
    review_app_id: str,
    review_app_data: Dict[str, Any],
    update_mask: str,
  ) -> Dict[str, Any]:
    """Update a review app.

    Args:
        review_app_id: The review app ID
        review_app_data: Updated review app data
        update_mask: Comma-separated list of fields to update (e.g., "agents,labeling_schemas")

    Returns:
        Dictionary containing updated review app
    """
    url = get_managed_evals_api_url(f'/review-apps/{review_app_id}')
    params = {'update_mask': update_mask}

    response = await fetch_databricks(
      method='PATCH',
      url=url,
      data=review_app_data,
      params=params,
    )

    return response

  async def get_review_app_by_experiment(self, experiment_id: str) -> Optional[Dict[str, Any]]:
    """Get review app for a specific experiment ID with ID caching.

    Note: Only the review_app_id mapping is cached, not the full review app data,
    to ensure we always get fresh schema and configuration data.

    Args:
        experiment_id: The MLflow experiment ID

    Returns:
        Dictionary containing review app details, or None if not found
    """
    # Check cache for the review_app_id mapping (since experiment:review_app is 1:1)
    if experiment_id in self._experiment_to_review_app_id_cache:
      cached_review_app_id = self._experiment_to_review_app_id_cache[experiment_id]
      try:
        # Always fetch fresh review app details from the API
        return await self.get_review_app(cached_review_app_id)
      except Exception:
        # Cache miss or review app deleted, remove from cache and proceed
        del self._experiment_to_review_app_id_cache[experiment_id]

    try:
      # Set the experiment context
      import logging
      import time

      logger = logging.getLogger(__name__)
      logger.info(f'ðŸ§¬ [MLFLOW GENAI] Setting experiment context: {experiment_id}')
      # Set experiment context for SDK operations
      mlflow.set_experiment(experiment_id=experiment_id)

      # Get review app using SDK
      logger.info('ðŸ§¬ [MLFLOW GENAI] Calling labeling.get_review_app()')
      genai_start = time.time()
      review_app = labeling.get_review_app()
      genai_time = time.time() - genai_start
      logger.info(f'ðŸ§¬ [MLFLOW GENAI] get_review_app() completed in {genai_time * 1000:.1f}ms')

      # Extract review app ID from SDK response
      if review_app:
        review_app_id = getattr(review_app, 'review_app_id', None)

        if review_app_id:
          # Cache the ID mapping for future requests
          self._experiment_to_review_app_id_cache[experiment_id] = review_app_id

          # Fetch full review app data from API (to get latest schemas, etc.)
          return await self.get_review_app(review_app_id)
      return None
    except Exception:
      # Fallback to REST API if SDK fails
      try:
        response = await self.list_review_apps(filter_string=f'experiment_id={experiment_id}')
        review_apps = response.get('review_apps', [])

        if review_apps:
          review_app = review_apps[0]  # Return the first (should be only) match

          # Cache the mapping for future requests
          review_app_id = review_app.get('review_app_id')
          if review_app_id:
            self._experiment_to_review_app_id_cache[experiment_id] = review_app_id

          return review_app
        return None
      except Exception:
        return None

  def get_cached_review_app_id(self, experiment_id: str) -> Optional[str]:
    """Get cached review app ID for an experiment without API call.

    Args:
        experiment_id: The MLflow experiment ID

    Returns:
        Cached review app ID, or None if not cached
    """
    return self._experiment_to_review_app_id_cache.get(experiment_id)


# Create a global instance for easy access
review_apps_utils = ReviewAppsUtils()
